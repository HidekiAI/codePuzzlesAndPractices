// The sequence of triangle numbers is generated by adding the natural numbers.  So the 7th triangle number would be
// 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
//      1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
//        1: 1                   1 -> 1/1
//        3: 1,3                3 -> 3/1
//        6: 1,2,3,6            6 -> 6/1, 6/2, 6/3 (6 % 3 == 0, so it's a factor, 6 % 4 != 0, so it's not a factor)
//       10: 1,2,5,10           10 -> 10/1, 10/2, 10/5, 10/10
//       15: 1,3,5,15           15 -> 15/1, 15/3, 15/5, 15/15
//       21: 1,3,7,21
//       28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over five hundred divisors?

// Whiteboard:
// * I need a function that will generate the nth triangle number (sum of 1..n)
// * I need a function that will generate the factors of a number as vector (so I can count the length)

// Wikipedia: https://en.wikipedia.org/wiki/Triangle_number says
// Tn = Sum(1..n) = (n^2 + n) / 2 = n(n+1)/2

// Postmortem:
// * there must be some mathematical formula to calculate the number of factors of a number
//   because it's not practical to iterate through all numbers to find factors over and
//   over again.  It cost about 50 mSec on lower than n=100's but as the iteration goes up
//   goes up, it gains about extrap 10mSec per 100 iterations.
//   In the end, I am at about 11,000 iterations (Triangle = 17907120, divisors = 480)
//   and stalling there for several minutes.
// * Once I submit the answer, the site gives solutions as well as writeup on how it was solved,
//   in which, I want to integrate and see how much better it performs.
// * Overall, this problem took over 2hrs to solve (it is at 2:25:10 mark) and still waiting
//   for the final answer.

const DIVISOR_COUNT: usize = 500;   // Triangle number 76576500 has 576 divisors.  Total time: 2:49:34

fn triangle_number(n: usize) -> usize {
    n * (n + 1) / 2
}
fn factors(n: usize) -> Vec<usize> {
    let mut factors = Vec::new();
    let mut factor_count = 0;
    for i in 1..=n {
        if n % i == 0 {
            // NOTE: For optimization, rather than pushing to Vec, I could just increment a counter and return final count...
            factors.push(i);
        }
    }
    factors
}

fn get_factor_count(n: usize) -> usize {
    let mut factor_count = 0;
    for i in 1..=n {
        if n % i == 0 {
            factor_count += 1;
        }
    }
    factor_count
}

fn main() {
    let mut n = 12300;  // NOTE: I already know that at 11900, Triangle=1707120 with 480 factor_count
    let mut largest_so_far = 0;
    let mut largest_so_far_triangle = 0;
    let mut avg_time_msec = 0.0;
    loop {
        let start_timer = std::time::Instant::now();
        let triangle = triangle_number(n);
        let factor_count = get_factor_count(triangle);
        if factor_count > largest_so_far {
            largest_so_far = factor_count;
            largest_so_far_triangle = triangle;
            println!(
                "\n{n} Triangle number {} has {} factors",
                triangle, factor_count
            );
        }
        if factor_count > DIVISOR_COUNT {
            println!(
                "\n{n} The first triangle number to have over {} divisors is {}",
                DIVISOR_COUNT, triangle
            );
            break;
        }
        n += 1;
        if n % 100 == 0 {
            println!("Avg {avg_time_msec} mSec: Checking triangle number [{}..{}], max so far {largest_so_far} for Triangle={largest_so_far_triangle}", n, n + 100);
        }
        avg_time_msec =  (avg_time_msec + start_timer.elapsed().as_millis() as f64) / 2.0;
    }

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_triangle_number() {
        assert_eq!(triangle_number(1), 1);
        assert_eq!(triangle_number(2), 3);
        assert_eq!(triangle_number(3), 6);
        assert_eq!(triangle_number(4), 10);
        assert_eq!(triangle_number(5), 15);
        assert_eq!(triangle_number(6), 21);
        assert_eq!(triangle_number(7), 28);
    }

    #[test]
    fn test_factors() {
        assert_eq!(factors(1), vec![1]);
        assert_eq!(get_factor_count(1), 1);

        assert_eq!(factors(3), vec![1, 3]);
        assert_eq!(get_factor_count(3), 2);

        assert_eq!(factors(6), vec![1, 2, 3, 6]);
        assert_eq!(get_factor_count(6), 4);

        assert_eq!(factors(10), vec![1, 2, 5, 10]);
        assert_eq!(get_factor_count(10), 4);

        assert_eq!(factors(15), vec![1, 3, 5, 15]);
        assert_eq!(get_factor_count(15), 4);

        assert_eq!(factors(21), vec![1, 3, 7, 21]);
        assert_eq!(get_factor_count(21), 4);

        assert_eq!(factors(28), vec![1, 2, 4, 7, 14, 28]);
        assert_eq!(get_factor_count(28), 6);
    }
}
